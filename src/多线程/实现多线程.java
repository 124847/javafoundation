package 多线程;
/*
进程 是正在运行的程序
是系统进行资源分配和调度的独立单位
每一个进程都有它在自己的内存空间和系统资源
进程：每个进程都有独立的代码和数据空间（进程上下文），进程间的切换会有较大的开销，一个进程包含1--n个线程。（进程是资源分配的最小单位）
线程：同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器(PC)，线程切换开销小。（线程是cpu调度的最小单位）
线程
一、线程的基本概念
　　线程是进程中执行运算的最小单位，是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点在运行中必不可少的资源，
    但它可与同属一个进程的其它线程共享进程所拥有的全部资源。一个线程可以创建和撤消另一个线程，同一进程中的多个线程之间可以并发执行。
    好处 ：（1）易于调度。

               （2）提高并发性。通过线程可方便有效地实现并发性。进程可创建多个线程来执行同一程序的不同部分。

               （3）开销少。创建线程比创建进程要快，所需开销很少。。

               （4）利于充分发挥多处理器的功能。通过创建多线程进程，每个线程在一个处理器上运行，从而实现应用程序的并发性，使每个处理器都得到充分运行

进程和线程的区别
进程是资源分配的最小单位，线程是CPU调度的最小单位

进程与程序的区别
程序仅仅只是一堆代码而已，而进程指的是程序的运行过程。



方式一 继承Thread类
定义一个类MyThread继承Thread类
在MyThread类中重写run() 方法
创建 MyThread类的对象
启动线程
xxx.start()

重写run()方法 因为 run() 是用来封装被线程执行的代码
run() 方法和start() 方法的区别
run 封装线程执行的代码 直接调用 相当于普通方法调用
start  启动线程 然后由jvm调用此线程的run 方法

设置和获取线程名称
setName(String xxx)

getName()

Thread.currentThread()  返回当前正在执行的线程对象的引用


线程调度

线程调度有两种调度模型
分时调度模型 ： 所有线程轮流使用CPU的使用权 平均分配每个线程占用cpu的时间片
抢占式调度模型 ： 优先让优先级高的线程使用cpu 如果线程的优先级相同 那么会随机选择一个 优先级高的线程获取的cpu时间片相对多一些

java 使用的时抢占式调度模型
假如计算机只有一个cpu 那么cpu在某一个时刻只能执行后一条指令 线程只用得到cpu时间片 也就是使用权 才可以执行指令 所以说多线程程序的执行是有随机性
因为抢到cpu的使用权是不一定的.


设置优先级 setPriority()

返回此线程优先级 getPriority()



sleep (long millis)  使当前正在执行的线程停留(暂停执行) 之u顶的毫秒数
join ()  等待这个线程死亡
setDaemon(boolean on)   将此线程标记为守护线程 当运行的线程都是守护线程时 java虚拟机将退出 但守护进程不是立即消失



方式二 实现Runnable接口
        重写run方法
        好处 避免 java单继承的局限性
        适合多个相同程序的代码去处理同一个资源的情况 把线程和程序的代码，数据有效分离 较好的体现了面向对象的设计思想


        Thread xxx = new Thread(继承Runnable接口的类,名字)


为了体现生成和消费过程中等待和唤醒,java提供了几个方法供我们使用 这几个方法在Object类中
Object类的等待和唤醒方法


void wait()   导致当前线程等待,直到另一个线程调用该对象的notify()方法或者 某一对象调用notifyAll()方法

void notify() 唤醒正在等待对象监视器的单个线程

void notifyAll() 唤醒正在等待对象监视器的所有线程

可以用 this调用
即 this.notifyAll
 */

public class 实现多线程 {
    public static void main(String[] args) {
        uu a1 = new uu("qwe");
        uu a2 = new uu();
        a1.setName("ert");
        a2.setName("qwe");
        a1.start();
        a2.start();
        System.out.println(a1.getName());
        System.out.println(Thread.currentThread().getId());
    }

}
