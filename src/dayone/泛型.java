package dayone;

import test.Generic;

/*
泛型时jdk5中引入的特性，它提供了编译时类的安全检测机制，该机制允许在编译时检测非法的类型
它的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数
一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参，那么参数化类型怎么理解呢？
顾名思义，就是将类型由原来的具体的类型参数化，然后在使用/调用时传入具体的类型
这种参数类型可以用在类，方法和接口中，分别被称为泛型类，泛型方法，泛型接口。

泛型的格式：
<类型> 指定一种类型的格式,这里的类型可以看成是形参
<类型1，类型2....> 指定多种类型的格式，多种类型之间用逗号隔开，这里的类型可以看成是形参
将来具体调用时候给定的类型可以看成是实参，并且实参的类型只能是引用数据类型

泛型的好处 把运行时期的问题提前到了编译期间

避免了强制类型转化



泛型类的定义格式 修饰符 class 类名 <类型> {}

范例 public class Generic<T> {}

此处的  T  可以随便写成任意表示， 常见的如T E K V 等形式的类型的参数用于表示泛型


泛型方法 不需要泛型类

格式 修饰符  <类型>  返回值类型 方法名 (类型 变量名字)
eg:  public <T> void show(T t){
}

泛型接口
public interface Generic<T>{
    void show()
}

继承泛型接口的类必须使用泛型

类型通配符
<?> 任意类型
<?extends类型> 类型或类型的子类
<?super类型> 类型或类型的父类
*/
//
public class 泛型<T> implements Generic<T> {
    public static void main(String[] args) {

    }

    @Override
    public void show(T t) {
        System.out.println(t);
    }
}
